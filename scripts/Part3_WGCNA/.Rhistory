ChytridGenes = sum(org == "chytrid"),
CyanoHubGenes = paste(gene[org == "cyano"], collapse = ", "),
ChytridHubGenes = paste(gene[org == "chytrid"], collapse = ", ")
) %>%
arrange(desc(CyanoGenes + ChytridGenes)) # Order by total genes
modules2plot <- summary_table$module
# Create a workbook
wb <- createWorkbook()
addWorksheet(wb, "WGCNA Summary")
# Add WGCNA color codes (base R handles them as named colors)
summary_table <- summary_table %>%
mutate(module_color = labels2colors(module))%>%
arrange(module)
# Write data (exclude the color column for display)
writeData(wb, sheet = 1, x = summary_table %>% select(-module_color), startCol = 1, startRow = 1)
# Highlight each cell in the module column with its module color
for (i in seq_len(nrow(summary_table))) {
mod_col <- summary_table$module_color[i]
# Set cell style with fill color
style <- createStyle(fgFill = mod_col, fontColour = "#FFFFFF")  # White text
addStyle(wb, sheet = 1, style = style, rows = i + 1, cols = 1, gridExpand = FALSE)
}
# Optional: make headers bold
headerStyle <- createStyle(textDecoration = "bold")
addStyle(wb, sheet = 1, style = headerStyle, rows = 1, cols = 1:5, gridExpand = TRUE)
# Save the Excel file
saveWorkbook(wb, "../../figures/WGCNA_summary_table.xlsx", overwrite = TRUE)
summary_table <- hub_genes %>%
group_by(module) %>%
summarise(
CyanoGenes = sum(org == "cyano"),
ChytridGenes = sum(org == "chytrid"),
CyanoHubGenes = paste(gene[org == "cyano"], collapse = ", "),
ChytridHubGenes = paste(gene[org == "chytrid"], collapse = ", ")
) %>%
arrange(desc(CyanoGenes + ChytridGenes)) # Order by total genes
modules2plot <- summary_table$module
summary_table
# Create a workbook
wb <- createWorkbook()
addWorksheet(wb, "WGCNA Summary")
# Add WGCNA color codes (base R handles them as named colors)
summary_table <- summary_table %>%
mutate(module_color = labels2colors(module))
summary_table
# Write data (exclude the color column for display)
writeData(wb, sheet = 1, x = summary_table %>% select(-module_color), startCol = 1, startRow = 1)
# Highlight each cell in the module column with its module color
for (i in seq_len(nrow(summary_table))) {
mod_col <- summary_table$module[i]
# Set cell style with fill color
style <- createStyle(fgFill = mod_col, fontColour = "#FFFFFF")  # White text
addStyle(wb, sheet = 1, style = style, rows = i + 1, cols = 1, gridExpand = FALSE)
}
# Optional: make headers bold
headerStyle <- createStyle(textDecoration = "bold")
addStyle(wb, sheet = 1, style = headerStyle, rows = 1, cols = 1:5, gridExpand = TRUE)
# Save the Excel file
saveWorkbook(wb, "../../figures/WGCNA_summary_table.xlsx", overwrite = TRUE)
## âœ… (3)  Plot network highlighting hub genes
library(igraph)
library(tidygraph)
library(ggraph)
library(purrr)
library(dplyr)
library(rlang)
library(ggplot2)
library(tidyr)
library(patchwork)
# Generate enhanced network plots per module
plots <- hub_genes %>%
filter(module %in% modules2plot) %>%  # remove or adjust this filter as needed
group_by(module) %>%
group_split() %>%
map(function(df) {
genes <- df$gene
mod <- unique(df$module)
# Subset adjacency matrix to only these genes
valid_genes <- intersect(genes, rownames(adjacency))
if (length(valid_genes) < 2) return(NULL)
adj_sub <- adjacency[valid_genes, valid_genes]
# Build edge list (upper triangle)
edge_df <- as.data.frame(as.table(adj_sub))
colnames(edge_df) <- c("from", "to", "weight")
edge_df <- edge_df %>%
filter(from != to) %>%
filter(as.numeric(factor(from)) < as.numeric(factor(to))) %>%
filter(weight > 0.05)  # adjustable threshold
if (nrow(edge_df) == 0) return(NULL)
# Node metadata: org and kWithin
nodes <- df %>%
filter(gene %in% c(edge_df$from, edge_df$to)) %>%
select(gene, org, kWithin) %>%
distinct() %>%
rename(name = gene)
g <- graph_from_data_frame(edge_df, vertices = nodes, directed = FALSE)
tg <- as_tbl_graph(g)
# Plot using ggraph:
ggraph(tg, layout = "fr") +
geom_edge_link(aes(alpha = weight), color = "black", width = 0.2, show.legend = FALSE) +       # thin black edges
geom_node_label(
aes(label = gsub("GeneID:", "", sub("_.*", "", name)),
color = org,  # text color mapped to org
fill = org), size = 4,
label.r = unit(0.25, "lines"),       # rounded corners = oval feel
label.padding = unit(0.25, "lines"),  # controls horizontal/vertical size
fontface = "bold", label.size = 0
) +
scale_fill_manual(values = c("cyano" = "white", "chytrid" = "black")) +
scale_color_manual(values = c("cyano" = "black", "chytrid" = "white")) +
guides(size = "none") +
theme_void() +
ggtitle(mod) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", colour = mod),
legend.position = "none",
plot.margin = unit(c(1,1,1,1), "cm")  # add margin
)+   coord_cartesian(clip = "off")
})
# Remove NULL plots if any
plots <- compact(plots)
wrap_plots(plots, ncol = 4)
pdf("../../figures/Fig5c.network.pdf", width = 12, height = 1)
wrap_plots(plots, ncol = 4)
dev.off()
pdf("../../figures/Fig5c.network.pdf", width = 12, height = 12)
wrap_plots(plots, ncol = 4)
dev.off()
pdf("../../figures/Fig5c.network.pdf", width = 12, height = 12)
wrap_plots(plots, ncol = 5)
dev.off()
# Generate enhanced network plots per module
plots <- hub_genes %>%
filter(module %in% modules2plot) %>%  # remove or adjust this filter as needed
group_by(module) %>%
group_split() %>%
map(function(df) {
genes <- df$gene
mod <- unique(df$module)
# Subset adjacency matrix to only these genes
valid_genes <- intersect(genes, rownames(adjacency))
if (length(valid_genes) < 2) return(NULL)
adj_sub <- adjacency[valid_genes, valid_genes]
# Build edge list (upper triangle)
edge_df <- as.data.frame(as.table(adj_sub))
colnames(edge_df) <- c("from", "to", "weight")
edge_df <- edge_df %>%
filter(from != to) %>%
filter(as.numeric(factor(from)) < as.numeric(factor(to))) %>%
filter(weight > 0.05)  # adjustable threshold
if (nrow(edge_df) == 0) return(NULL)
# Node metadata: org and kWithin
nodes <- df %>%
filter(gene %in% c(edge_df$from, edge_df$to)) %>%
select(gene, org, kWithin) %>%
distinct() %>%
rename(name = gene)
g <- graph_from_data_frame(edge_df, vertices = nodes, directed = FALSE)
tg <- as_tbl_graph(g)
# Plot using ggraph:
ggraph(tg, layout = "fr") +
geom_edge_link(aes(alpha = weight), color = "black", width = 0.2, show.legend = FALSE) +       # thin black edges
geom_node_label(
aes(label = gsub("GeneID:", "", sub("_.*", "", name)),
color = org,  # text color mapped to org
fill = org), size = 4,
label.r = unit(0.25, "lines"),       # rounded corners = oval feel
label.padding = unit(0.25, "lines"),  # controls horizontal/vertical size
fontface = "bold", label.size = 0
) +
scale_fill_manual(values = c("cyano" = "white", "chytrid" = "black")) +
scale_color_manual(values = c("cyano" = "black", "chytrid" = "white")) +
guides(size = "none") +
theme_void() +
ggtitle(mod) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", fill = mod),
legend.position = "none",
plot.margin = unit(c(1,1,1,1), "cm")  # add margin
)+   coord_cartesian(clip = "off")
})
pdf("../../figures/Fig5c.network.pdf", width = 12, height = 13)
wrap_plots(plots, ncol = 5)
dev.off()
# Generate enhanced network plots per module
plots <- hub_genes %>%
filter(module %in% modules2plot) %>%  # remove or adjust this filter as needed
group_by(module) %>%
group_split() %>%
map(function(df) {
genes <- df$gene
mod <- unique(df$module)
# Subset adjacency matrix to only these genes
valid_genes <- intersect(genes, rownames(adjacency))
if (length(valid_genes) < 2) return(NULL)
adj_sub <- adjacency[valid_genes, valid_genes]
# Build edge list (upper triangle)
edge_df <- as.data.frame(as.table(adj_sub))
colnames(edge_df) <- c("from", "to", "weight")
edge_df <- edge_df %>%
filter(from != to) %>%
filter(as.numeric(factor(from)) < as.numeric(factor(to))) %>%
filter(weight > 0.05)  # adjustable threshold
if (nrow(edge_df) == 0) return(NULL)
# Node metadata: org and kWithin
nodes <- df %>%
filter(gene %in% c(edge_df$from, edge_df$to)) %>%
select(gene, org, kWithin) %>%
distinct() %>%
rename(name = gene)
g <- graph_from_data_frame(edge_df, vertices = nodes, directed = FALSE)
tg <- as_tbl_graph(g)
# Plot using ggraph:
ggraph(tg, layout = "fr") +
geom_edge_link(aes(alpha = weight), color = "black", width = 0.2, show.legend = FALSE) +       # thin black edges
geom_node_label(
aes(label = gsub("GeneID:", "", sub("_.*", "", name)),
color = org,  # text color mapped to org
fill = org), size = 4,
label.r = unit(0.25, "lines"),       # rounded corners = oval feel
label.padding = unit(0.25, "lines"),  # controls horizontal/vertical size
fontface = "bold", label.size = 0
) +
scale_fill_manual(values = c("cyano" = "white", "chytrid" = "black")) +
scale_color_manual(values = c("cyano" = "black", "chytrid" = "white")) +
guides(size = "none") +
theme_void() +
ggtitle(mod) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", colour = mod),
legend.position = "none",
plot.margin = unit(c(1,1,1,1), "cm")  # add margin
)+   coord_cartesian(clip = "off")
})
# Remove NULL plots if any
plots <- compact(plots)
pdf("../../figures/Fig5c.network.pdf", width = 12, height = 13)
wrap_plots(plots, ncol = 5)
dev.off()
# Load necessary libraries
## Results of previous analysis
setwd("../Part2_DEG/")
source("fullAnalysis.R")
setwd("../Part3_WGCNA/")
## ============================================================
## ðŸ“¦ 1. Load Variance-stabilized matrices from previous script
## ============================================================
vst_cyano <- contrast_cyanogenome$vstr
vst_chy <- contrast_chytridgenome$vstr
vst_chy %>% nrow # 835 genes
vst_cyano %>% nrow # 555 genes
## For big data
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
##############################################
## I. Single species co-expression analysis ##
##############################################
## ===============================
## âœ… 2.Pick soft power threshold
## ===============================
# The soft threshold (Î²) is a key parameter in WGCNA.
# It raises the correlation matrix to this power to emphasize strong correlations
# and suppress weak ones, so your network approximates a scale-free topology â€”
# the biological reality that a few genes are highly connected (hubs) while most arenâ€™t.
# Scale-free topology fit index (SFT.R.sq): Good â‰¥ 0.8 (â‰¥0.9 better); bad <0.6
# Mean connectivity between 5 and 100 is usually reasonable to not lose meaningful connections.
pickSoftPow <- function(vst){
par(mfrow = c(2, 1))
sth <- pickSoftThreshold(t(vst), powerVector = c(1:20), verbose = 5)
plot(sth$fitIndices$Power, sth$fitIndices$SFT.R.sq, type="b",
xlab="Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2",
main="Scale-Free Topology Fit")
abline(h=0.8, col="red", lty=2); abline(h=0.9, col="red", lty=1)
plot(sth$fitIndices$Power, sth$fitIndices$mean.k., type="b",
xlab="Soft Threshold (power)", ylab="Mean connectivity",
main="Scale-Free Topology Fit")
abline(h=5, col="red", lty=2)
par(mfrow = c(1, ))
}
pickSoftPow(vst_chy)
softPower_chy <- 8 # mean connectivity 1.5900 ok
softPower_chy <- 14 # mean connectivity 2.090 ok
## ===============================
## ðŸ”— 3. Build modules
## ===============================
cor <- WGCNA::cor
net_chy <- blockwiseModules(
datExpr = t(vst_chy),
power = 8,
TOMType = "signed", minModuleSize = 30, reassignThreshold = 0,
mergeCutHeight = 0.25, saveTOMs = TRUE, saveTOMFileBase = "chyTOM",
verbose = 3)
# Number of modules identified:
table(net_chy$colors)
# Change grey to NA to rm unassigned geneds
net_chy$colors[net_chy$colors == "grey"] <- "white"
net_cyano <- blockwiseModules(
datExpr = t(vst_cyano),
power = 12,
TOMType = "signed", minModuleSize = 30, reassignThreshold = 0,
mergeCutHeight = 0.25, saveTOMs = TRUE, saveTOMFileBase = "cyanoTOM",
verbose = 3)
# Number of modules identified:
table(net_cyano$colors)
# Change grey to NA
net_cyano$colors[net_cyano$colors == "grey"] <- "white"
## ===============================
## ðŸŽ¨ 4. Dendrogram & colors
## ===============================
plotDendroAndColors(
net_chy$dendrograms[[1]],
net_chy$colors[net_chy$blockGenes[[1]]], "Module colors",
dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
plotDendroAndColors(
net_cyano$dendrograms[[1]],
net_cyano$colors[net_cyano$blockGenes[[1]]], "Module colors",
dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
## ==============================
## 5. Run enrichment on modules
## ==============================
res <- lapply(names(table(net_chy$colors)), function(i){
getGOBubbleZ(universe = colnames(t(vst_chy)),
annotation = annotationChytrid,
genelist = names(net_chy$colors)[net_chy$colors == i],
GO_df = GO_chytrid, isbubble = F)
})
res <- lapply(names(table(net_cyano$colors)), function(i){
getGOBubbleZ(universe = colnames(t(vst_cyano)),
annotation = annotationCyano,
genelist = names(net_cyano$colors)[net_cyano$colors == i],
GO_df = GO_cyano, isbubble = F)
})
## =================
## 6. Find our DEG
## =================
table(na.omit(net_chy$colors[unique(fullDEGTable$geneName)]))
data.frame(modules=na.omit(net_chy$colors[unique(fullDEGTable$geneName)])) %>%
arrange(modules) ## white = no module
table(na.omit(net_cyano$colors[unique(fullDEGTable$geneName)]))
data.frame(modules=na.omit(net_cyano$colors[unique(fullDEGTable$geneName)])) %>%
arrange(modules) ## white = no module
treatment <- ifelse(grepl("^control", colnames(vst_chy)), 0, 1)
moduleTraitCor = cor(net_chy$MEs, treatment, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, length(treatment))
moduleTraitCor; moduleTraitPvalue
labeledHeatmap(Matrix = moduleTraitCor, xLabels = "Treatment",
yLabels = names(net_chy$MEs), colors = blueWhiteRed(50))
treatment <- ifelse(grepl("chy", colnames(vst_chy)), 0, 1)
moduleTraitCor <- cor(net_chy$MEs, treatment, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, length(treatment))
moduleTraitCor; moduleTraitPvalue
labeledHeatmap(Matrix = moduleTraitCor, xLabels = "Treatment",
yLabels = names(net_chy$MEs), colors = blueWhiteRed(50))
#####################################
## II. Dual co-expression analysis ##
#####################################
# We keep only "both" (dual transcriptome)
# vst_cyano: genes x samples
# vst_chy: genes x samples
shared_samples <- intersect(colnames(vst_cyano), colnames(vst_chy))
# Keep same sample order
vst_cyano_both <- vst_cyano[, shared_samples]
vst_chy_both <- vst_chy[, shared_samples]
# Make sure samples are in same order:
vst_cyano_both <- vst_cyano_both[, colnames(vst_chy_both)]
stopifnot(all(colnames(vst_cyano_both) == colnames(vst_chy_both)))
## combined
vst_combined <- rbind(vst_chy_both, vst_cyano_both)
## ===============================
## âœ… 2.Pick soft power threshold
## ===============================
pickSoftPow(vst_combined)
softPower_combined <- 1 # to avoid too high connectivity
## ===============================
## ðŸ”— 3. Build modules
## ===============================
cor <- WGCNA::cor
net_combined <- blockwiseModules(
datExpr = t(vst_combined),
power = softPower_combined,
corFnc = "bicor",
networkType = "signed",
TOMType = "signed",
minModuleSize = 30,
mergeCutHeight = 0.25,
reassignThreshold = 0,
verbose = 5
)
# Number of modules identified:
table(net_combined$colors)
plotDendroAndColors(
net_combined$dendrograms[[1]],
net_combined$colors[net_combined$blockGenes[[1]]], "Module colors",
dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
net_combined$colors
treatment <- ifelse(grepl("^control", colnames(vst_combined)), 0, 1)
moduleTraitCor = cor(net_combined$MEs, treatment,use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, length(treatment))
moduleTraitCor; moduleTraitPvalue
# If you plot eigengene boxplots for these 3, youâ€™ll see how they change by treatment.
meta <- data.frame(
Sample = rownames(net_combined$MEs),
Treatment = sub("_.*", "",  rownames(net_combined$MEs)),
stringsAsFactors = TRUE)
plot_df <- net_combined$MEs %>%
as.data.frame() %>%
mutate(Sample = rownames(.)) %>%
left_join(meta, by = "Sample")
ggplot(plot_df, aes(x = Treatment, y = MEgreenyellow, fill = Treatment)) +
geom_boxplot() +
geom_jitter(width = 0.2, size = 2) +
labs(title = "Module Eigengene for MEgreenyellow",
y = "Module Eigengene Value") +
theme_minimal() + theme(legend.position = "none")
moduleTraitCor; moduleTraitPvalue
## Color greenyellow
ggplot(aes(x=1,y=1))+
geom_point(pch=21, fill = "greenyellow")
## Color greenyellow
ggplot(data.frame(x=1,y=1), aes(x,y))+
geom_point(pch=21, fill = "greenyellow")
## Color greenyellow
ggplot(data.frame(x=1,y=1), aes(x,y))+
geom_point(pch=21, size = 20, fill = "greenyellow")
## Results of previous analysis
setwd("../Part2_DEG/")
source("fullAnalysis.R")
setwd("../Part3_WGCNA/")
## ============================================================
## ðŸ“¦ 1. Load Variance-stabilized matrices from previous script
## ============================================================
vst_cyano <- contrast_cyanogenome$vstr
vst_chy <- contrast_chytridgenome$vstr
vst_chy %>% nrow # 835 genes
vst_cyano %>% nrow # 555 genes
## For big data
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
##############################################
## I. Single species co-expression analysis ##
##############################################
## ===============================
## âœ… 2.Pick soft power threshold
## ===============================
# The soft threshold (Î²) is a key parameter in WGCNA.
# It raises the correlation matrix to this power to emphasize strong correlations
# and suppress weak ones, so your network approximates a scale-free topology â€”
# the biological reality that a few genes are highly connected (hubs) while most arenâ€™t.
# Scale-free topology fit index (SFT.R.sq): Good â‰¥ 0.8 (â‰¥0.9 better); bad <0.6
# Mean connectivity between 5 and 100 is usually reasonable to not lose meaningful connections.
pickSoftPow <- function(vst){
par(mfrow = c(2, 1))
sth <- pickSoftThreshold(t(vst), powerVector = c(1:20), verbose = 5)
plot(sth$fitIndices$Power, sth$fitIndices$SFT.R.sq, type="b",
xlab="Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2",
main="Scale-Free Topology Fit")
abline(h=0.8, col="red", lty=2); abline(h=0.9, col="red", lty=1)
plot(sth$fitIndices$Power, sth$fitIndices$mean.k., type="b",
xlab="Soft Threshold (power)", ylab="Mean connectivity",
main="Scale-Free Topology Fit")
abline(h=5, col="red", lty=2)
par(mfrow = c(1, ))
}
pickSoftPow(vst_chy)
## ===============================
## ðŸ”— 3. Build modules
## ===============================
cor <- WGCNA::cor
net_chy <- blockwiseModules(
datExpr = t(vst_chy),
power = 8,
TOMType = "signed", minModuleSize = 30, reassignThreshold = 0,
mergeCutHeight = 0.25, saveTOMs = TRUE, saveTOMFileBase = "chyTOM",
verbose = 3)
#####################################
## II. Dual co-expression analysis ##
#####################################
# We keep only "both" (dual transcriptome)
# vst_cyano: genes x samples
# vst_chy: genes x samples
shared_samples <- intersect(colnames(vst_cyano), colnames(vst_chy))
# Keep same sample order
vst_cyano_both <- vst_cyano[, shared_samples]
vst_chy_both <- vst_chy[, shared_samples]
# Make sure samples are in same order:
vst_cyano_both <- vst_cyano_both[, colnames(vst_chy_both)]
stopifnot(all(colnames(vst_cyano_both) == colnames(vst_chy_both)))
## combined
vst_combined <- rbind(vst_chy_both, vst_cyano_both)
## ===============================
## âœ… 2.Pick soft power threshold
## ===============================
pickSoftPow(vst_combined)
softPower_combined <- 1 # to avoid too high connectivity
## ===============================
## ðŸ”— 3. Build modules
## ===============================
cor <- WGCNA::cor
net_combined <- blockwiseModules(
datExpr = t(vst_combined),
power = softPower_combined,
corFnc = "bicor",
networkType = "signed",
TOMType = "signed",
minModuleSize = 30,
mergeCutHeight = 0.25,
reassignThreshold = 0,
verbose = 5
)
# Number of modules identified:
table(net_combined$colors)
sum(table(net_combined$colors))
